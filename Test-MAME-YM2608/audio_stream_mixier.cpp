#include "audio_stream_mixier.hpp"
#include <algorithm>

AudioStreamMixier::AudioStreamMixier(chip::OPNA& chip, size_t duration, QObject* parent) :
    QIODevice(parent),
    chip_(chip),
    duration_(duration),
    bufferSize_(chip_.getRate() * duration_ / 1000 * 2),
    readIntrCount_(0)
{
}

AudioStreamMixier::~AudioStreamMixier()
{
    if (hasRun()) stop();
}

void AudioStreamMixier::start()
{
    open(QIODevice::ReadOnly);
}

void AudioStreamMixier::stop()
{
    close();
}

bool AudioStreamMixier::hasRun()
{
    return isOpen();
}

qint64 AudioStreamMixier::readData(char* data, qint64 maxlen)
{
    qint64 generatedCount;
    if (isFirstRead_) {   // Fill device buffer in first read
        generatedCount = maxlen >> 2;
        isFirstRead_ = false;
    }
    else {  // Fill appropriate counts
        generatedCount = std::min((static_cast<qint64>(bufferSize_ >> 1)), (maxlen >> 2));
    }
    size_t requiredCount = static_cast<size_t>(generatedCount);
    size_t readIntrCountNumer = (chip_.getRate() * 5) >> 2;
    int16* destPtr = reinterpret_cast<int16*>(data);

    size_t count;
    while (requiredCount) {
        if (!readIntrCount_) {	// Read data
            // Read pattern data in here
            // 1 row = 6 counts = 1/16 notes
            int bpm = 120;
            readIntrCount_ = readIntrCountNumer / bpm;
        }

        count = std::min(readIntrCount_, requiredCount);
        requiredCount -= count;
        readIntrCount_ -= count;

        chip_.mix(destPtr, count);

        destPtr += (count << 1);	// Move head
    }

    return generatedCount << 2; // Return generated bytes count
}

qint64 AudioStreamMixier::writeData(const char *data, qint64 len)   // No use
{
    Q_UNUSED(data);
    Q_UNUSED(len);
    return 0;
}
